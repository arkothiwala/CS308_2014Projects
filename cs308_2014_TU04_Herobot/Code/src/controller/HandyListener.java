package controller;

import com.leapmotion.leap.*;
import java.util.Iterator;

import network.Commander;

/*
 * Listens for frames generated by the Leap Motion sensor
 */
public class HandyListener extends Listener {
	
	// Interface for sending commands over to the robotic arm
	// This commander is a connection to the bot via Xbee
	Commander commander;
	
	// number of frames received (from leap motion) since
	// last update of arm position
	int frameCount = 0;
	
	// when frameCount reaches MAX_FRAME_COUNT, a message to update the arm 
	// position is sent; setting to 0 means update messages are sent for every frame received
	int MAX_FRAME_COUNT = 0;
	
	// Boolean to manage gripper locking while grasping an object
	boolean gripperLocked = false;
	
	// Constants for motion of the arm
	// ARM_LOW is 10, ARM_HIGH is 90 - a spread of 80 degrees.
	// LEAP_PALM_LOW and LEAP_PALM_HIGH are indicators of palm orientation
	// of the user, value received from Leap Motion sensor lies between these
	// values and is mapped to an integer between ARM_LOW and ARM_HIGH
	int ARM_LOW = 0x0A;
	int ARM_HIGH = 0x5A;	
	double LEAP_PALM_LOW = 0.30;
	double LEAP_PALM_HIGH = 0.99;
	double ARM_RATIO = (ARM_HIGH - ARM_LOW) / (LEAP_PALM_HIGH - LEAP_PALM_LOW);
	
	// Constants for motion of gripper
	// Description of variables is similar to above
	int GRIP_LOW = 0x5B;
	int GRIP_HIGH = 0xA0;
	double LEAP_GRIP_LOW = 30.0;
	double LEAP_GRIP_HIGH = 130.0;
	double GRIP_RATIO = (GRIP_HIGH - GRIP_LOW) / (LEAP_GRIP_HIGH - LEAP_GRIP_LOW);
	
	// NOTE: The message that is sent to the bot is an 8-bit integer.
	// If the value is between ARM_LOW (= 10) and ARM_HIGH (= 90), it is interpreted by the bot
	// as a signal to position the arm, and the final angle to which the arm is
	// to be moved is decided by adding some constant to the signal.
	// If the value is between GRIP_HIGH (= 91) and GRIP_LOW (= 160), is is interpreted by the bot
	// as a signal to position the gripper and again the orientation is decided by
	// the bot by adding some constant to the received signal.
	// Values less between 0 and ARM_LOW (= 10) are control signals
	// The important ones are for moving the bot:
	// 0x08 - moves bot forward
	// 0x02 - moves bot backward
	// 0x04 - moves bot left
	// 0x06 - moves bot right
	
	public void onInit(Controller controller) {
        System.out.println("Leap: Initialized");
    }

    public void onConnect(Controller controller) {
        System.out.println("Leap: Connected");
    }

    public void onDisconnect(Controller controller) {
        System.out.println("Leap: Disconnected");
    }

    public void onExit(Controller controller) {
        System.out.println("Leap: Exited");
    }
    
    public void setCommander(Commander commander) {
    	this.commander = commander;
    }
    
    public void send(Integer n) {
    	commander.sendXbee(n);
    }
    
    // Returns the orientation of the palm given a frame of data
    // The double returned is a real number between 0 and 1 indicating
    // the component of the normal to the palm on the plane of the
    // computer screen
    private Double getPalmOrientation(Frame frame) {
    	Double armOrt = -1.0;    	
    	if (frame.isValid()) { 
    		if (!frame.hands().isEmpty()) {    	
		    	Vector normal = frame.hands().rightmost().palmNormal();	
		    	armOrt = Math.sqrt(normal.getX()*normal.getX() + normal.getY()*normal.getY()); 
    		}
    	}
    	return armOrt;
    }
    
    // Returns the distance between the index finger and thumb of the rightmost
    // hand in the field of view of the Leap Motion sensor
    private Double getGripDistance(Frame frame) {
    	Double gripDist = -1.0;
    	if (frame.isValid()) {
	    	if (!frame.hands().isEmpty() && frame.fingers().count() >= 2) {
	    		
	    		// right hand used to control arm
	    		Hand rightHand = frame.hands().rightmost();
	    		
	    		// get the two fingers with smallest X co-ords
	    		Finger thumb = null, index = null;
	    		Float minX = 9999f, minX2 = minX;
	    		Iterator<Finger> it = rightHand.fingers().iterator();
	    		while (it.hasNext()) {
	    			Finger finger = it.next();
	    			Float tipXPos = finger.stabilizedTipPosition().getX();
	    			if (tipXPos < minX) {
	    				minX2 = minX; index = thumb;
	    				minX = tipXPos; thumb = finger;    				
	    			} else if (tipXPos < minX2) {
	    				minX2 = tipXPos; index = finger;
	    			}
	    		}
	    		Vector thumbTip = thumb.stabilizedTipPosition();
	    		Vector indexTip = index.stabilizedTipPosition();
	    		gripDist = (double) thumbTip.distanceTo(indexTip);
	    	}
    	}
    	
    	return gripDist;
    }
    
    // Checks if the user wants to lock the position of the gripper
    // For locking the gripper, there need to be at least two hands in the
    // sensor's field of view, and the leftmost hand must have no fingers
    // outstretched (clenched fist with the back of the hand facing the sensor)
    private boolean checkGripperLock(Frame frame) {
    	boolean locked = false;
    	if (frame.isValid()) {
    		if (frame.hands().count() > 1) {
    			Hand leftHand = frame.hands().leftmost();
    			if (leftHand.fingers().isEmpty())
    				locked = true;
    		}
    	}
    	return locked;
    }

    public void onFrame(Controller controller) {
    	
    	Frame currFrame = controller.frame();    	
    	Frame prevFrame = controller.frame(1);
    	
    	// get orientation of palm to decide orientation of robotic arm
    	Double currOrt = getPalmOrientation(currFrame);
    	Double prevOrt = getPalmOrientation(prevFrame);
    	
    	// track index finger and thumb to determine arm grip movement
    	Double currGripDist = getGripDistance(currFrame);
    	Double prevGripDist = getGripDistance(prevFrame);
    	
    	// check for gripper locking
    	gripperLocked = checkGripperLock(currFrame);
    	
    	// use the command interface to send updated position of 
    	// arm and gripper
    	if (frameCount == MAX_FRAME_COUNT) { 
    		
    		// Update arm position
    		if (currOrt > 0 && prevOrt > 0) {
    			Double delta = currOrt - prevOrt;
    			if (Math.abs(delta) > 0.01) {
    				Integer pos = (int) (ARM_RATIO * (currOrt - LEAP_PALM_LOW)) + ARM_LOW;
    				if (pos >= ARM_LOW && pos <= ARM_HIGH) {
    					commander.sendXbee(pos);
    					System.out.println("Sending to arm: " + pos);
    				}
    			} else {
    				// User is not moving palm, check for movement between
    				// forefinger and thumb
    				if (currGripDist > 0 && prevGripDist > 0 && !gripperLocked) {
    	    			Double dGrip = currGripDist - prevGripDist;
    	    			if (Math.abs(dGrip) > 0.1) {
    	    				Integer pos = (int) (GRIP_RATIO * (currGripDist - LEAP_GRIP_LOW)) + GRIP_LOW;
    	    				int mid = (GRIP_LOW + GRIP_HIGH) / 2;
    	    				pos = mid - (pos - mid);
    	    				if (pos >= GRIP_LOW && pos <= GRIP_HIGH) {
    	    					commander.sendXbee(pos);
    	    					System.out.println("Sending to gripper: " + pos);
    	    				}
    	    			}
    	    		}
    			}
    		}    		    	
    		frameCount = 0; // reset frame counter
    	} else {
    		frameCount++;
    	}
    	
    }
    
}
